from __future__ import annotations

import json
import time
import uuid
from dataclasses import asdict
from pathlib import Path
from typing import Any, Dict, List, Tuple

from .metrics import aggregate_metrics
from .types import Document, RunResult, ScoredItem, TestCase

# Reproducibility metadata (catalog tracking)
from .run_meta import build_catalog_meta


def now_run_id() -> str:
    return time.strftime("%Y%m%d-%H%M%S") + "-" + uuid.uuid4().hex[:8]


def _write_jsonl(path: Path, rows: List[Dict[str, Any]]) -> None:
    with path.open("w", encoding="utf-8") as f:
        for r in rows:
            f.write(json.dumps(r, ensure_ascii=False) + "\n")


def _item_to_dict(x: ScoredItem) -> Dict[str, Any]:
    return {"doc_id": x.doc_id, "score": x.score, "extra": x.extra}


def result_to_event(rr: RunResult) -> Dict[str, Any]:
    d = {
        "case_id": rr.case.case_id,
        "status": rr.status,
        "raw_text": rr.case.raw_text,
        "intent_text": rr.case.intent_text,
        "expected_doc_ids": rr.case.expected_doc_ids,
        "expected_category": rr.case.expected_category,
        "needs_clarification": rr.case.needs_clarification,
        "notes": rr.case.notes,
        "timings_ms": rr.timings_ms,
        "error": rr.error,
        "dense": [_item_to_dict(x) for x in rr.dense],
        "bm25": [_item_to_dict(x) for x in rr.bm25],
        "fused": [_item_to_dict(x) for x in rr.fused],
        "reranked": [_item_to_dict(x) for x in rr.reranked],
        "final": [_item_to_dict(x) for x in rr.final],
    }
    return d


def inject_catalog_meta(summary: Dict[str, Any], *, catalog_path: Path, n_rows: int) -> Dict[str, Any]:
    """
    Inject catalog reproducibility metadata into summary.
    Call this right after loading the catalog (or right before writing summary.json/report.md).

    Example:
        catalog = load_catalog_csv(catalog_path)
        summary = {...}
        inject_catalog_meta(summary, catalog_path=catalog_path, n_rows=len(catalog))
        write_report(run_dir, summary)
        write_summary_json(run_dir, summary)
    """
    summary["meta"] = build_catalog_meta(str(catalog_path), n_rows=n_rows)
    return summary


def write_report(run_dir: Path, summary: Dict[str, Any]) -> None:
    """Write markdown report to report.md (and optionally keep summary.md)."""
    lines: List[str] = []
    lines.append(f"# Run Report: {summary['run_id']}")
    lines.append("")
    lines.append(f"- total_cases: {summary['counts']['total']}")
    lines.append(f"- evaluated_cases: {summary['counts']['evaluated']}")
    lines.append(f"- clarify_cases: {summary['counts']['clarify']}")
    lines.append("")

    # ===== Run Metadata (catalog tracking) =====
    meta = summary.get("meta") or {}
    if meta:
        lines.append("## Run Metadata")
        lines.append("")
        lines.append(f"- catalog_path: {meta.get('catalog_path')}")
        lines.append(f"- catalog_n_rows: {meta.get('catalog_n_rows')}")
        lines.append(f"- catalog_sha256: {meta.get('catalog_sha256')}")
        lines.append("")
    # =========================================

    lines.append("## Metrics")
    lines.append("")
    if summary.get("metrics"):
        for k, v in summary["metrics"].items():
            lines.append(f"- {k}: {v:.4f}")
    else:
        lines.append("(no metrics)")
    lines.append("")
    lines.append("## Notes")
    lines.append("")
    lines.append("- This report is generated by ivhl.")

    text = "\n".join(lines) + "\n"
    # Primary report file
    (run_dir / "report.md").write_text(text, encoding="utf-8")
    # Backward-compatible name (optional). Comment out if you don't want it.
    (run_dir / "summary.md").write_text(text, encoding="utf-8")
